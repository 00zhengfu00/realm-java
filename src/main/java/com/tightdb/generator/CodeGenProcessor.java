package com.tightdb.generator;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.TypeKind;
import javax.lang.model.type.TypeMirror;

import org.apache.commons.lang.StringUtils;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.context.Context;

import com.tightdb.doc.TemplateRenderer;
import com.tightdb.lib.Table;

@SupportedSourceVersion(SourceVersion.RELEASE_6)
public class CodeGenProcessor extends AbstractAnnotationProcessor {

	public static final String INFO_GENERATED = "/* This file was automatically generated by TightDB. */";

	private final static Set<String> NUM_TYPES;
	private final static Set<String> OTHER_TYPES;

	private TemplateRenderer renderer = new TemplateRenderer();

	static {
		NUM_TYPES = new HashSet<String>(Arrays.asList("long", "int", "byte", "short", "Long", "Integer", "Byte", "Short"));
		OTHER_TYPES = new HashSet<String>(Arrays.asList("String", "Date"));
	}

	private Map<String, TypeElement> tables = new HashMap<String, TypeElement>();
	private Map<String, TypeElement> subtables = new HashMap<String, TypeElement>();

	@Override
	public void processAnnotations(Set<? extends TypeElement> annotations, RoundEnvironment env) throws Exception {
		CodeRenderer renderer = new CodeRenderer();
		String content = renderer.test();
		writeToFile("a.b", "Test.java", content + new Date());
		
		for (TypeElement annotation : annotations) {
			String annotationName = annotation.getQualifiedName().toString();
			if (annotationName.equals(Table.class.getCanonicalName())) {
				Set<? extends Element> elements = env.getElementsAnnotatedWith(annotation);
				//processAnnotatedElements(elements);
			} else {
				warn("Unexpected annotation: " + annotationName);
			}
		}
	}

	private void processAnnotatedElements(Set<? extends Element> elements) throws IOException {
		info("Processing " + elements.size() + " elements...");
		prepareTables(elements);

		for (Element element : elements) {
			if (element instanceof TypeElement) {
				TypeElement model = (TypeElement) element;
				String modelType = model.getQualifiedName().toString();

				List<VariableElement> fields = getFields(element);

				info("Generating code for entity with " + fields.size() + " columns...");

				// get the capitalized model name
				String entity = StringUtils.capitalize(model.getSimpleName().toString());

				/*********** Prepare the attributes for the templates ****************/

				/* Construct the list of columns */

				int index = 0;
				final List<Field> columns = new ArrayList<Field>();
				for (VariableElement field : fields) {
					String columnType = getColumnType(field);
					String fieldType = getFieldType(field);
					String fieldName = field.getSimpleName().toString();

					boolean isSubtable = isSubtable(fieldType);
					String subtype = isSubtable ? getSubtableType(field) : null;

					Map<String, Object> fieldAttrs = new HashMap<String, Object>();
					fieldAttrs.put("index", index++);
					fieldAttrs.put("columnType", columnType);
					fieldAttrs.put("isSubtable", isSubtable);
					fieldAttrs.put("subtype", subtype);

					columns.add(new Field(fieldType, fieldName, fieldAttrs));
				}

				/* Set the attributes */

				boolean isNested = isSubtable(modelType);
				Map<String, Object> attributes = new HashMap<String, Object>();
				attributes.put("entity", entity);
				attributes.put("columns", columns);
				attributes.put("isNested", isNested);
				attributes.put("info", INFO_GENERATED);

				/*********** Construct the table class ****************/

				Model table = new Model();
				List<Model> tableMethods = new ArrayList<Model>();

				table.put("name", entity + "Table");
				table.put("macro", "table");
				table.put("attributes", attributes);
				table.put("methods", tableMethods);

				/* Construct the "add" method in the table class */

				List<Model> addParams = new ArrayList<Model>();

				for (VariableElement field : fields) {
					if (!isSubtable(fieldType(field))) {
						Model param = new Model();
						param.put("type", fieldType(field));
						param.put("name", field.getSimpleName().toString());
						addParams.add(param);
					}
				}

				Model methodAdd = new Model();
				methodAdd.put("macro", "table_add");
				methodAdd.put("params", addParams);
				tableMethods.add(methodAdd);

				/* Construct the "insert" method in the table class */

				Model methodInsert = new Model();
				methodInsert.put("macro", "table_insert");
				methodInsert.put("params", addParams);
				tableMethods.add(methodInsert);

				/*********** Construct the cursor class ****************/

				Model cursor = new Model();
				cursor.put("name", entity);
				cursor.put("macro", "cursor");
				cursor.put("attributes", attributes);

				/*********** Construct the view class ****************/

				Model view = new Model();
				view.put("name", entity + "View");
				view.put("macro", "view");
				view.put("attributes", attributes);

				/*********** Construct the query class ****************/

				Model query = new Model();
				query.put("name", entity + "Query");
				query.put("macro", "query");
				query.put("attributes", attributes);
			}
		}

		Context context = new VelocityContext();
		context.put("x", "foo");
		String content = renderer.render("test.vm", context);
		writeToFile("com.tightdb.newgenerated", "Test.java", content);
	}

	private List<VariableElement> getFields(Element element) {
		List<VariableElement> fields = new ArrayList<VariableElement>();

		for (Element enclosedElement : element.getEnclosedElements()) {
			if (enclosedElement.getKind().equals(ElementKind.FIELD)) {
				if (enclosedElement instanceof VariableElement) {
					VariableElement field = (VariableElement) enclosedElement;
					fields.add(field);
				}
			}
		}

		return fields;
	}

	private void prepareTables(Set<? extends Element> elements) {
		for (Element element : elements) {
			if (element instanceof TypeElement) {
				TypeElement model = (TypeElement) element;
				String name = model.getQualifiedName().toString();
				if (isReferencedBy(model, elements)) {
					info("- detected subtable: " + name);
					subtables.put(name, model);
				} else {
					info("- detected top-level table: " + name);
					tables.put(name, model);
				}
			}
		}
	}

	private boolean isReferencedBy(TypeElement model, Set<? extends Element> elements) {
		String modelType = model.getQualifiedName().toString();

		for (Element element : elements) {
			for (Element enclosedElement : element.getEnclosedElements()) {
				if (enclosedElement.getKind().equals(ElementKind.FIELD)) {
					if (enclosedElement instanceof VariableElement) {
						VariableElement field = (VariableElement) enclosedElement;
						TypeMirror fieldType = field.asType();
						if (fieldType.getKind().equals(TypeKind.DECLARED)) {
							Element typeAsElement = typeUtils.asElement(fieldType);
							if (typeAsElement instanceof TypeElement) {
								TypeElement typeElement = (TypeElement) typeAsElement;
								if (typeElement.getQualifiedName().toString().equals(modelType)) {
									return true;
								}
							}
						}
					}
				}
			}
		}

		return false;
	}

	private String getColumnType(VariableElement field) {
		String type = field.asType().toString();

		if (NUM_TYPES.contains(type)) {
			type = "Long";
		} else if ("boolean".equalsIgnoreCase(type)) {
			type = "Boolean";
		} else if ("byte[]".equalsIgnoreCase(type) || "ByteBuffer".equalsIgnoreCase(type)) {
			type = "Binary";
		} else if (isSubtable(type)) {
			type = "Table";
		} else if (!OTHER_TYPES.contains(type)) {
			type = "Mixed";
		}

		return type;
	}

	private boolean isSubtable(String type) {
		return subtables.containsKey(type);
	}

	private String fieldType(VariableElement field) {
		return field.asType().toString();
	}

	private String fieldSimpleType(VariableElement field) {
		return fieldType(field).replaceFirst("<.*>", "");
	}

	private String getSubtableType(VariableElement field) {
		return StringUtils.capitalize(fieldSimpleType(field));
	}

	private String getFieldType(VariableElement field) {
		String type = fieldType(field);
		String simpleType = fieldSimpleType(field);

		if (NUM_TYPES.contains(simpleType)) {
			type = "long";
		} else if (simpleType.equals("byte[]")) {
			type = "java.nio.ByteBuffer";
		} else if (simpleType.equals("Object")) {
			type = "com.tightdb.Mixed";
		}

		return type;
	}

}
