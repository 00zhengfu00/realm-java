/*
 * Copyright 2018 Realm Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.realm;

import android.support.test.runner.AndroidJUnit4;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;

import java.lang.reflect.Constructor;
import java.util.Collections;
import java.util.Date;

import io.realm.entities.AllJavaTypes;
import io.realm.internal.ColumnInfo;
import io.realm.internal.RealmObjectProxy;
import io.realm.internal.Row;
import io.realm.internal.Table;
import io.realm.internal.objectstore.OsObjectBuilder;
import io.realm.rule.TestRealmConfigurationFactory;

import static junit.framework.Assert.assertEquals;
import static junit.framework.Assert.fail;
import static org.junit.Assert.assertArrayEquals;

/**
 * Ideally all of the functionality is tested through the code generated by the annotation processor
 * So these tests are mostly here to isolate the behaviour from the more complex proxy classes.
 */
@RunWith(AndroidJUnit4.class)
public class OsObjectBuilderTests {
    @Rule
    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
    @Rule
    public final ExpectedException thrown = ExpectedException.none();

    private Realm realm;

    @Before
    public void setUp() {
        realm = Realm.getInstance(configFactory.createConfiguration());
    }

    @After
    public void tearDown() {
        if (realm != null && !realm.isClosed()) {
            realm.close();
        }
    }

    @Test
    public void createOrUpdate_newObject() {
        realm.beginTransaction();

        Table table = realm.getTable(AllJavaTypes.class);

        // Build object data
        OsObjectBuilder builder = new OsObjectBuilder(table);
        builder.addInteger(AllJavaTypes.FIELD_ID, 1);
        builder.addString(AllJavaTypes.FIELD_STRING, "foo");
        builder.addInteger(AllJavaTypes.FIELD_BYTE, 1);
        builder.addInteger(AllJavaTypes.FIELD_SHORT, 1);
        builder.addInteger(AllJavaTypes.FIELD_INT, 1);
        builder.addInteger(AllJavaTypes.FIELD_LONG, 1);
        builder.addDouble(AllJavaTypes.FIELD_DOUBLE, 1.234);
        builder.addFloat(AllJavaTypes.FIELD_FLOAT, 1.23F);
        builder.addBoolean(AllJavaTypes.FIELD_BOOLEAN, true);
        builder.addDate(AllJavaTypes.FIELD_DATE, new Date(1000));
        builder.addByteArray(AllJavaTypes.FIELD_BINARY, new byte[] {1, 2, 3});

        AllJavaTypes obj = realm.createObject(AllJavaTypes.class, 42);
        builder.addObject(AllJavaTypes.FIELD_OBJECT, (RealmObjectProxy) obj);

        RealmList<AllJavaTypes> objectList = new RealmList<>(obj, obj, obj);
        builder.addObjectList(AllJavaTypes.FIELD_LIST, objectList);

        RealmList<String> stringList = new RealmList<>("foo", "bar", "baz");
        builder.addStringList(AllJavaTypes.FIELD_STRING_LIST, stringList);

        RealmList<Byte> byteList = new RealmList<>((byte) 1, (byte) 2, (byte) 3, (byte) 4, (byte) 5);
        builder.addByteList(AllJavaTypes.FIELD_BYTE_LIST, byteList);

        RealmList<Short> shortList = new RealmList<>((short) 1, (short) 2, (short) 3, (short) 4, (short) 5);
        builder.addShortList(AllJavaTypes.FIELD_SHORT_LIST, shortList);

        RealmList<Integer> intList = new RealmList<>(1, 2, 3, 4, 5);
        builder.addIntegerList(AllJavaTypes.FIELD_INTEGER_LIST, intList);

        RealmList<Long> longList = new RealmList<>(1L, 2L, 3L, 4L, 5L);
        builder.addLongList(AllJavaTypes.FIELD_LONG_LIST, longList);

        RealmList<byte[]> binaryList = new RealmList<>(new byte[] {1,2,3},new byte[] {1,2,3},new byte[] {1,2,3});
        builder.addByteArrayList(AllJavaTypes.FIELD_BINARY_LIST, binaryList);

        RealmList<Boolean> booleanList = new RealmList<>(true, false, true);
        builder.addBooleanList(AllJavaTypes.FIELD_BOOLEAN_LIST, booleanList);

        RealmList<Double> doubleList = new RealmList<>(1.12, 1.23, 1.34);
        builder.addDoubleList(AllJavaTypes.FIELD_DOUBLE_LIST, doubleList);

        RealmList<Float> floatList = new RealmList<>(1.12F, 1.23F, 1.34F);
        builder.addFloatList(AllJavaTypes.FIELD_FLOAT_LIST, floatList);

        RealmList<Date> dateList = new RealmList<>(new Date(1000), new Date(2000), new Date(3000));
        builder.addDateList(AllJavaTypes.FIELD_DATE_LIST, dateList);

        // Create row
        Row row = builder.createNewObject();

        // Check values
        AllJavaTypes managedObject = convertToManagedObject(AllJavaTypes.class, realm, row);
        assertEquals("foo", managedObject.getFieldString());
        assertEquals(1, managedObject.getFieldId());
        assertEquals(1, managedObject.getFieldByte());
        assertEquals(1, managedObject.getFieldShort());
        assertEquals(1, managedObject.getFieldInt());
        assertEquals(1, managedObject.getFieldLong());
        assertEquals(1.23F, managedObject.getFieldFloat());
        assertEquals(1.234, managedObject.getFieldDouble());
        assertEquals(true, managedObject.isFieldBoolean());
        assertEquals(new Date(1000), managedObject.getFieldDate());
        assertArrayEquals(new byte[] {1,2,3}, managedObject.getFieldBinary());
        assertEquals(obj, managedObject.getFieldObject());
        assertArrayEquals(objectList.toArray(), managedObject.getFieldList().toArray());
        assertArrayEquals(stringList.toArray(), managedObject.getFieldStringList().toArray());
        assertArrayEquals(byteList.toArray(), managedObject.getFieldByteList().toArray());
        assertArrayEquals(shortList.toArray(), managedObject.getFieldShortList().toArray());
        assertArrayEquals(intList.toArray(), managedObject.getFieldIntegerList().toArray());
        assertArrayEquals(longList.toArray(), managedObject.getFieldLongList().toArray());
        assertArrayEquals(doubleList.toArray(), managedObject.getFieldDoubleList().toArray());
        assertArrayEquals(floatList.toArray(), managedObject.getFieldFloatList().toArray());
        assertArrayEquals(binaryList.toArray(), managedObject.getFieldBinaryList().toArray());
        assertArrayEquals(booleanList.toArray(), managedObject.getFieldBooleanList().toArray());
        assertArrayEquals(dateList.toArray(), managedObject.getFieldDateList().toArray());
    }

    @Test
    public void createOrUpdate_updateExistingObject() {
        // TODO
    }

    @Test
    public void createOrUpdate_updateTypeWithNoPrimaryKeyThrows() {
        // TODO
    }

    @Test
    public void createOrUpdate_updateObjectWithNoPrimaryKeyValueThrows() {
        // TODO
    }

    private <T extends RealmModel> T convertToManagedObject(Class<T> clazz, Realm realm, Row row) {
        // Prepare ObjectContext before creating the Proxy
        final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
        ColumnInfo columnInfo = realm.getSchema().getColumnInfo(clazz);
        objectContext.set(realm, row, columnInfo, false, Collections.emptyList());

        // Instantiate the proxy class using the prepared Object Context
        String proxyClassName = clazz.getCanonicalName().replace(".", "_") + "RealmProxy";
        try {
            Class<?> proxyClass = Class.forName("io.realm." + proxyClassName);
            Constructor<?> constructor = proxyClass.getDeclaredConstructors()[0];
            constructor.setAccessible(true);
            //noinspection unchecked
            return (T) constructor.newInstance();
        } catch (Exception e) {
            fail("Could not create proxy class: " + e.toString());
        }

        throw new IllegalStateException();
    }
}
